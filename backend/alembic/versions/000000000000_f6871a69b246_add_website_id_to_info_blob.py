"""add website id to info_blob
Revision ID: f6871a69b246
Revises: f56172ebc222
Create Date: 2024-06-12 08:46:04.589646
"""

import sqlalchemy as sa
from sqlalchemy import Integer, join, select, update
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import column, table

from alembic import op

# revision identifiers, used by Alembic
revision = 'f6871a69b246'
down_revision = 'f56172ebc222'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # Rename table
    op.rename_table('crawls', 'websites')
    op.alter_column('crawl_runs', 'crawl_id', new_column_name='website_id')

    # Add tenant_id column to websites
    op.add_column('websites', sa.Column('tenant_id', sa.Integer(), nullable=True))

    # Reflect tables
    users_table = table('users', column('uuid', UUID), column('tenant_id', Integer))
    website_table = table(
        'websites',
        column('id', UUID),
        column('user_id', Integer),
        column('tenant_id', Integer),
    )

    # Get connection
    connection = op.get_bind()

    # Query to get user_id and tenant_id from users table
    user_tenant_pairs = connection.execute(
        select(users_table.c.uuid, users_table.c.tenant_id)
    ).fetchall()

    # Update tenant_id in websites based on user_id
    for user_id, tenant_id in user_tenant_pairs:
        connection.execute(
            update(website_table)
            .where(website_table.c.user_id == user_id)
            .values(tenant_id=tenant_id)
        )

    # Create foreign key constraint
    op.create_foreign_key(
        'websites_tenant_id_fkey',
        'websites',
        'tenants',
        ['tenant_id'],
        ['id'],
        ondelete='CASCADE',
    )

    # Optionally, make the tenant_id column non-nullable if appropriate
    op.alter_column('websites', 'tenant_id', nullable=False)

    # Add tenant_id to crawl_runs
    op.add_column('crawl_runs', sa.Column('tenant_id', sa.Integer(), nullable=True))

    # Reflect table
    crawl_run_table = table(
        'crawl_runs',
        column('id', UUID),
        column('website_id', UUID),
        column('tenant_id', Integer),
    )

    # Join users, websites, and crawl_runs
    join_stmt = join(
        website_table,
        users_table,
        website_table.c.user_id == users_table.c.uuid,
    )
    join_stmt = join(
        join_stmt,
        crawl_run_table,
        website_table.c.id == crawl_run_table.c.website_id,
    )

    # Query to get website_table_id and tenant_id
    query = select(website_table.c.id, users_table.c.tenant_id).select_from(join_stmt)
    website_tenant_pairs = connection.execute(query).fetchall()

    # Update tenant_id in crawl_runs based on website_id
    for website_id, tenant_id in website_tenant_pairs:
        connection.execute(
            update(crawl_run_table)
            .where(crawl_run_table.c.website_id == website_id)
            .values(tenant_id=tenant_id)
        )

    # Create foreign key constraint
    op.create_foreign_key(
        'crawl_runs_tenant_id_fkey',
        'crawl_runs',
        'tenants',
        ['tenant_id'],
        ['id'],
        ondelete='CASCADE',
    )

    # Optionally, make the tenant_id column non-nullable if appropriate
    op.alter_column('crawl_runs', 'tenant_id', nullable=False)

    op.alter_column('info_blobs', 'group_id', nullable=True)
    op.add_column('info_blobs', sa.Column('website_id', UUID, nullable=True))
    op.create_foreign_key(
        'info_blobs_website_id_fkey',
        'info_blobs',
        'websites',
        ['website_id'],
        ['id'],
        ondelete='CASCADE',
    )
    op.add_column('websites', sa.Column('embedding_model_id', sa.UUID(), nullable=True))
    op.create_foreign_key(
        'websites_embedding_model_id_fkey',
        'websites',
        'embedding_models',
        ['embedding_model_id'],
        ['id'],
        ondelete='SET NULL',
    )

    # reflect group table
    groups_table = table(
        'groups',
        column('id', UUID),
        column('embedding_model_id', UUID),
    )
    website_table = table(
        'websites',
        column('id', UUID),
        column('user_id', Integer),
        column('tenant_id', Integer),
        column('group_id', UUID),
        column('embedding_model_id', UUID),
    )

    # Query to get group_id and embedding_model_id from groups table
    group_embedding_model_pairs = connection.execute(
        select(groups_table.c.id, groups_table.c.embedding_model_id)
    ).fetchall()

    # Update tenant_id in your_table based on user_id
    for group_id, embedding_model_id in group_embedding_model_pairs:
        if group_id is None or embedding_model_id is None:
            continue

        connection.execute(
            update(website_table)
            .where(website_table.c.group_id == group_id)
            .values(embedding_model_id=embedding_model_id)
        )

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    op.drop_constraint(
        'websites_embedding_model_id_fkey', 'websites', type_='foreignkey'
    )
    op.drop_column('websites', 'embedding_model_id')

    # Downgrade info_blobs
    op.drop_constraint('info_blobs_website_id_fkey', 'info_blobs', type_='foreignkey')
    op.alter_column('info_blobs', 'group_id', nullable=False)
    op.drop_column('info_blobs', 'website_id')

    # Drop foreign key constraint
    op.drop_constraint('websites_tenant_id_fkey', 'websites', type_='foreignkey')
    op.drop_constraint('crawl_runs_tenant_id_fkey', 'crawl_runs', type_='foreignkey')

    # Drop tenant_id column
    op.drop_column('websites', 'tenant_id')
    op.drop_column('crawl_runs', 'tenant_id')

    op.rename_table('websites', 'crawls')
    op.alter_column('crawl_runs', 'website_id', new_column_name='crawl_id')
    # ### end Alembic commands ###
